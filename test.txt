import utime
import time
import binascii
import ucollections
import random
import machine
import framebuf, sys
import uos
import rp2
import re
import struct
import onewire, ds18x20

import library.ads1x15 as ads1x15
import library.w25qxx as w25qxx

from config import *
from machine import Timer
from machine import ADC
from gc import collect
# from machine import WDT
from library.flash import Flash
from library.oled import Oled
from library.modem import Modem
from library.logger import Logger
from library.file import File
from library.sc16is7xx import SC16IS7XX
from library.rtc_pcf import RTC_PCF
from library.crc import *
from library.constants import *

from machine import Pin, UART, SPI, I2C
from time import localtime, mktime, ticks_ms

def init_modules():
    MODULES_STATUSES = 255
    
    i2c0 = I2C(0, scl=Pin(13), sda=Pin(12), freq=100000)
    devices = i2c0.scan()
    log.log(log.INFO, f"I2C0 devices found: {len(devices)}")
    for device in devices:
        log.log(log.INFO, f"Decimal address: {device} | Hex address: {hex(device)}")

    # I2C1 Init
    # RTC, ADS1113, SSD1306, PCA,
    i2c1 = I2C(1, scl=Pin(11), sda=Pin(10), freq=100000)
    devices = i2c1.scan()
    log.log(log.INFO, f"I2C1 devices found: {len(devices)}")
    for device in devices:
        log.log(log.INFO, f" Decimal address: {device} | Hex address: {hex(device)}")
    log.log(log.INFO, f"I2C1 Address: {hex(i2c1.scan()[0]).upper()}")  # Display device address
    log.log(log.INFO, f"I2C1 Configuration: {str(i2c1)}")
    
    # I2C0 Init
    # RS-482-2 (SC16IS74),
    
    # SPI
    spi = SPI(0, 10_000_000, sck=Pin(18), mosi=Pin(19), miso=Pin(16))
    
    # GD25Q64 Flash 64 Kb
    cs_GD64 = Pin(26, Pin.OUT)
    cs_GD64.value(1)
    flash_gd = None
    try:
        flash_gd = Flash(spi, cs_GD64)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<0)
        log.log(log.INFO, f"W25qxx is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<0)
        log.log(log.ERROR, f"W25qxx is {e}")
        
    # DS18B20 Температура с One Wire ++
    fl_DS18B20 = False
    ds_pin = machine.Pin(15)
    ds_sensor, roms = None, None
    try:
        ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin))
        roms = ds_sensor.scan()
        ds_sensor.convert_temp()
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<1)
        log.log(log.INFO, f"Found DS18B20: {roms}")
    except Exception as e:
        fl_DS18B20 = False
        MODULES_STATUSES = MODULES_STATUSES | (1<<1)
        log.log(log.ERROR, f"DS18B20: NOT {e}")

    # OLED
    WIDTH = 128
    HEIGHT = 32
    oled = None
    try:
        oled = Oled(WIDTH, HEIGHT, i2c1)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<2)
        oled.displayText("Init Modules...", (10,10))
        log.log(log.INFO, f"OLED is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<2)
        log.log(log.ERROR, f"OLED: NOT {e}")
    
    # RTC_PCF
    adr_RTC = 0x51  # Адрес RTC DS
    adr_DT = 0x04  # Адрес регистра врeмени
    rtc_p = None
    try:
        rtc_p = RTC_PCF(i2c1)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<3)
        log.log(log.INFO, f"RTC_PCF is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<3)
        log.log(log.ERROR, f"RTC_PCF: NOT {e}")


    # ADS1113
    InVoltDivider = 18.2
    InDiod = 0.4
    addr = 0x48
    gain = 1
    ads = None
    try:
        ads = ads1x15.ADS1115(i2c1, addr, gain)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<4)
        log.log(log.INFO, f"ADS1115 is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<4)
        log.log(log.ERROR, f"ADS1115: NOT {e}")
    addr_PCA = 0x41
    i2c1.writeto(addr_PCA, b"\x03\x00")  # pin -> out

    # Port RS-485-2, через I2C. sc16is740 speed: 19200
    rs_2 = None
    try:
        i2c1.writeto(addr_PCA, b"\x01\xFF")
        rs_2 = SC16IS7XX(i2c0, debug=False)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<5)
        log.log(log.INFO, f"SC16IS7XX is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<5)
        log.log(log.ERROR, f"SC16IS7XX: NOT {e}")
    
    modem_var = Modem(3, (1,4,5), SERVER_IP, PORT, EMERGENCY_PHONE)
    
    oled.Oled(["Turning on", "modem ...", ""])
     
    if modem_var.on() == 1:
        log.log(log.INFO, f"Modem is on")
        oled.displayText("Modem is on", (0,0))
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<6)
    else:
        MODULES_STATUSES = MODULES_STATUSES | (1<<6)
        log.log(log.ERROR, f"cmd Mod On: Bad!")
        
    return i2c1, flash_gd, ds_sensor, roms, oled, rtc_p, ads, rs_2, modem_var, MODULES_STATUSES

def display_general_info():
    display_list = []
    
    datetime = rtc_p.ReadTime(1)
    display_list.append(datetime)
    
    try:
        # DS18B20
        ds_sensor.convert_temp()
        temperature = do_18B20()
        dict_val['t1'] = temperature
        dict_val['t2'] = do_t_CPU(t_CPU)
        display_list.append("t_DS:{0:0.1f}".format(temperature))
    except Exception as e:
        log.log(log.ERROR, e)
        temperature = do_t_CPU(t_CPU)
        display_list.append("tCPU:{0:0.1f} ".format(temperature))
        
    # Voltage
    InVoltDivider = 18.2
    Kv = 2.048 * InVoltDivider / 32767  # делитель V
    V = read_ADS(1, 10) * Kv
    display_list[-1] = display_list[-1] + "Vs:{0:0.1f}".format(V)
    dict_val['v1'] = V
    display_list.append(f"{MODULES_STATUSES:08b}  {error_code:02X}")
    dict_val['ms'] = MODULES_STATUSES
    if not (MODULES_STATUSES & 2 << 1) >> 2:
        oled.Oled(display_list)
    else:
        log.log(log.ERROR, "OLED: Bad")

def set_time(str_time):
    sp0 = str_time[23:25]
    sp0 = sp0 + str_time[20:22]
    sp0 = sp0 + str_time[17:19]
    sp0 = sp0 + str_time[14:16]
    sp0 = sp0 + '01' #День недели
    sp0 = sp0 + str_time[11:13]
    sp0 = sp0 + str_time[8:10] #Год/
    bp0 = binascii.unhexlify(sp0)
    rtc_p.SetTime(NowTime=bp0)
    IS_CLOCK_SET = True
def send_modbus_req(s):
    global ms_RS, IS_WAIT_MODBUS_RESPONSE
    Pin_RS0.on()
    ms_RS = time.ticks_add(time.ticks_ms(), len(s) + 2)
    uart.write(s)
    IS_WAIT_MODBUS_RESPONSE = True
    time.sleep_ms(10)

def do_t_CPU(adc_t):
    v_tcpu = adc_t.read_u16() * 3.3 / (65535)
    t1 = 27 - (v_tcpu - 0.709) / 0.001721
    return t1

def do_Vsys():
    V = Pin_sys.read_u16() * 3.3 / (65535)
    V *= 3
    return V

def do_18B20():
    try:
        for rom in roms:
            t1 = ds_sensor.read_temp(rom)
        return t1
    except Exception as e:
        raise e

def read_ADS(Kanal, dlit):
    b = bytearray()
    b.append(0x01)
    b.append(0xFC + Kanal)
    i2c1.writeto(addr_PCA, b)
    time.sleep_ms(dlit)
    nV = ads.read(0)
    return nV

def form_packet(packet_type):
    packet = [PACKET_START_CHARACTER, OBJECT_ID, packet_type, time.time().to_bytes(4, "little"), DATA_START_CHARACTER]
    if packet_type == EMERGENCY_PACKET_TYPE:
        for cell_number in sorted(cell_emergency_mapped_view.keys()):
            packet.extend((cell_number.to_bytes(2, "little"), sum(cell_emergency_mapped_view[cell_number]).to_bytes(1,"little"), DATA_DELIMITER))
        packet.extend((DATA_END_CHARACTER, PACKET_END_CHARACTER))
    if packet_type == REGULAR_PACKET_TYPE:
        for cell_number in sorted(cell_regular_values.keys()):
            packet.append(cell_number.to_bytes(1, "little"))
            for reg_num in sorted(cell_regular_values[cell_number].keys()):
                packet.extend((MICOM_REGULAR_REGISTER[reg_num], REGISTER_NUM_VALUE_DELIMITER, cell_regular_values[cell_number][reg_num], REGISTER_DELIMITER))
            packet.append(DATA_DELIMITER)
        packet.extend((DATA_END_CHARACTER, DATA_START_CHARACTER))
        for name in ["v1", "t1", "t2", "ms", "re"]:
            try:
                packet.extend((name.encode(), bytearray(struct.pack("f", dict_val[name])) , DATA_DELIMITER))
            except:
                pass
        packet.extend((DATA_END_CHARACTER, PACKET_END_CHARACTER))
    return packet

def send_general_regular_packet():
    packet = form_packet(REGULAR_PACKET_TYPE)
    if modem_var.get_status() != -1:
        for i in packet:
            modem_var.send_number(i)
        log.log(log.INFO, f'Send regular packet : {packet}')
    else:
        File('unsended_packets.txt').writeln(f'{packet}')
    return packet

def send_emergency_packet():
    packet = form_packet(EMERGENCY_PACKET_TYPE)
    if modem_var.get_status() != -1:
        for i in packet:
            modem_var.send_number(i)
        log.log(log.INFO, f'Send emergency packet : {packet}')
    else:
        File('unsended_packets.txt').writeln(f'{packet}')
    return packet

def send_sms():
    while True:
        modem_var.send_sms_mode_on()
        data = modem_var.process_sms()
        if data and '>' in data:
            modem_var.send_number('MESSAGE'.encode())
            modem_var.send_number((26).to_bytes(1, "little"))
            modem_var.send_data()
            break

    log.log(log.INFO, 'Some modules are fail to start. Send SMS message to emergency contact')

# ------------------------------- END FUNCTION ------------------------------------

# ---------------------------------START-------------------------------------------

log = Logger(f'object_{int.from_bytes(OBJECT_ID, "little")}_main.log')

ms_RS = 0  # Задержка для передачи пакета RS-485

fl_ADS = False  # ADS в процессе

PACKET_FORM_STATE = EMERGENCY_PACKET_STATE 
SERVER_SEND_STATE = SERVER_SEND_NOT_STATE

IS_WAIT_MODBUS_RESPONSE = False
IS_FILE_DONWLOAD = False
IS_FILE_SUCCESS = False
IS_CLOCK_SET = False
SENDED_RS_WORK = False
SENDED_RS_D_WORK = False

response = b''
last_time_modbus_req = time.ticks_ms()
last_time_regular_packet = time.time()
last_time_sec = time.time()
last_time_DO_0 = time.ticks_ms()
last_time_DO_1 = time.ticks_ms()

# 
dict_val = {}

# Modbus var
DI_32_REQUEST_TEMPLATE = bytearray(
    [0x01, 0x03, 0x00, 0x63, 0x00, 0x02]
)

DI_32_REQUEST_LIST = []

for i in range(DI_32_COUNT):
    request = DI_32_REQUEST_TEMPLATE[:]
    request[0] = DI_32_ADDRESSES[i]
    crc = crc16(request)
    request += crc
    
    DI_32_REQUEST_LIST.append(request)

MICOM_REQUEST_TEMPLATE = bytearray(
    [0x01, 0x03, 0x00, 0x00, 0x00, 0x01]
)

MICOM_REQUEST_LIST = []

for i in range(MICOM_RELAY_COUNT):
    MICOM_REQUEST_REG_LIST = []
    request = MICOM_REQUEST_TEMPLATE[:]
    request[0] = MICOM_RELAY_ADDRESSES[i]
    for reg_i in range(len(MICOM_REGULAR_REGISTER)):
        request[2] = MICOM_REGULAR_REGISTER[reg_i][0]
        request[3] = MICOM_REGULAR_REGISTER[reg_i][1]

        crc = crc16(request)
        request += crc
        MICOM_REQUEST_REG_LIST.append(request)
    MICOM_REQUEST_LIST.append(MICOM_REQUEST_REG_LIST)

# TODO error code definition
error_codes = [0x01, 0x02, 0x03]
error_code = 0x00

cell_regular_values = {}
cell_emergency_values = {}


cell_regular_response_fail_count = [0 for i in range(MICOM_RELAY_COUNT)]
cell_emergency_response_fail_count = [0 for i in range(DI_32_COUNT)]
cell_emergency_mapped_view = {}

current_DI_32_address_index = 0
current_micom_address_index = 0
current_MICOM_REGULAR_REGISTER_index = 0

#
last_rs_state = 0
to_count = 0
# Pins
DO_0 = Pin(7, Pin.OUT)  # Pin Output
DO_1 = Pin(8, Pin.OUT)
DO_2 = Pin(9, Pin.OUT)
Pin(29, machine.Pin.IN)
Pin_sys = ADC(3)  #
Pin_int_RS2 = Pin(28, Pin.IN, Pin.PULL_UP)  # Pin I2C --> Rs-485_2
Pin_RTC_INT = Pin(27, Pin.IN, Pin.PULL_UP)  # RTC DS3231

# LED
led = machine.Pin(25, machine.Pin.OUT)
fl_led = False
led.value(0)

t_CPU = ADC(4)

log.log(log.INFO, uos.uname())

# UART
Pin_RS0 = Pin(2, Pin.OUT)  # RS-485 RE/DE
Pin_RS0.value(0)

i2c1, flash_gd, ds_sensor, roms, oled, rtc_p, ads, rs_2, modem_var, MODULES_STATUSES = init_modules()

uart = None
if RS_PORT == 1:
    MODULES_STATUSES = MODULES_STATUSES & ~(1<<7)
    uart = UART(0, tx=machine.Pin(0), rx=machine.Pin(1))
    uart.init(baudrate=38400, bits=8, parity=None, stop=1, timeout=30)
    
addr_PCA = 0x41

display_general_info()

timer0 = Timer()
timer0.init(
    period=1000, mode=Timer.PERIODIC, callback=lambda t: led.value(not led.value())
)
if 'SIM not inserted' in modem_var.init():
    error_code = error_code | (1<<2)

if modem_var.get_status() != -1:
    str_time = modem_var.get_time()
    if str_time.startswith('+CCLK'):
        set_time(str_time)
    elif str_time.startswith('TIMEOUT'):
        IS_CLOCK_SET = False
    log.log(log.INFO, "Modem and time are configured")        
else:
    log.log(log.INFO, "Modem and time can't be configured cause of CME error")
    

attempt_count_file = File('attempt.txt')
attempt_file_content = attempt_count_file.read()
attempts_count = len(attempt_file_content.split("\n"))
dict_val['re'] = attempts_count
if MODULES_STATUSES == 0:
    attempts_count = 0
elif attempts_count < 3:
    attempt_count_file.writeln("Not all modules started properly")
    log.log(log.INFO, 'Some modules are fail to start. Initiate restart process')
    machine.reset()
elif modem_var.get_status != -1:
    SEND_SMS = False
    while True:
        modem_var.connect_to_server()
        data = modem_var.process_tcpip()
    
        if data and 'IP INITIAL' in data:
            break
        elif data and re.search('.*<.*>.*', data):
            error_code = error_code & ~(1<<0)
            cmd_from_server = data[data.index('<')+1:data.rindex('>')]
        elif data and 'CONNECT FAIL' in data:
            log.log(log.INFO, 'Can\'t connect to server')
        elif data and to_count < 3 and 'TIMEOUT' in data:
            log.log(log.INFO, 'Can\'t connect to server')
            to_count += 1
            modem_var.connect_to_server()
        elif to_count >= 3:
            log.log(log.INFO, 'Fail to connect to server 3 times')
            to_count = 0
            error_code = error_code | (1<<0)
            modem_var.current_at_cmd_index = -1
            display_general_info()
            packet = b''            
            for i in form_packet(REGULAR_PACKET_TYPE):
                packet += i
            File('unsended_packets.txt').writeln(f'{packet}')
            SEND_SMS = True
        elif data and  '>' in str(data):        
            send_general_regular_packet()
            modem_var.send_data()
    if SEND_SMS:
        log.log(log.INFO, "Some modules are fail to start. 3 times attempted to restart system. Doesn't help.")
        send_sms()
    else:
        log.log(log.INFO, 'Some modules are fail to start. Send message to server')
        
while True:
    if Pin_RS0.value():
        if time.ticks_diff(time.ticks_ms(), ms_RS) <= 0:
            Pin_RS0.off()
    
    if IS_WAIT_MODBUS_RESPONSE and time.ticks_diff(time.ticks_ms(), last_time_modbus_req) > 35:
        if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
            cell_regular_response_fail_count[current_micom_address_index] += 1
            if cell_regular_response_fail_count[current_micom_address_index] > 50:
                cell_regular_response_fail_count[current_micom_address_index] = 50
            if current_micom_address_index + 1 == MICOM_RELAY_COUNT:
                SERVER_SEND_STATE = SERVER_SEND_REGULAR_STATE
            if current_MICOM_REGULAR_REGISTER_index + 1 == len(MICOM_REGULAR_REGISTER):
                current_micom_address_index = (
                    current_micom_address_index + 1
                ) % MICOM_RELAY_COUNT
            current_MICOM_REGULAR_REGISTER_index = (current_MICOM_REGULAR_REGISTER_index + 1) % len(MICOM_REGULAR_REGISTER)
        elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
            cell_emergency_response_fail_count[current_DI_32_address_index] += 1
            if cell_emergency_response_fail_count[current_DI_32_address_index] > 50:
                cell_emergency_response_fail_count[current_DI_32_address_index] = 50
            current_DI_32_address_index = (
                current_DI_32_address_index + 1
            ) % DI_32_COUNT
        response = b''
        IS_WAIT_MODBUS_RESPONSE = False
        last_time_modbus_req = time.ticks_ms()
    
    if PACKET_FORM_STATE == REGULAR_PACKET_STATE and time.ticks_diff(time.ticks_ms(), last_time_DO_1) > 100:
        DO_1.toggle()
        DO_0.off()
        last_time_DO_1 = time.ticks_ms()  
    
    if PACKET_FORM_STATE == EMERGENCY_PACKET_STATE and time.ticks_diff(time.ticks_ms(), last_time_DO_0) > 100:
        DO_0.toggle()
        DO_1.off()
        last_time_DO_0 = time.ticks_ms()  
    
    if abs(time.time() - last_time_sec) >= 1:
        if sum(cell_regular_response_fail_count) + sum(cell_emergency_response_fail_count) < 50 * (DI_32_COUNT + MICOM_RELAY_COUNT):
            if not SENDED_RS_WORK:
                SENDED_RS_WORK = True
                SENDED_RS_D_WORK = False
                log.log(log.INFO, 'RS-485 work')
            error_code = error_code & ~(1<<1)
            MODULES_STATUSES = MODULES_STATUSES & ~(1<<7)
        else:
            if not SENDED_RS_D_WORK:
                SENDED_RS_D_WORK = True
                SENDED_RS_WORK = False
                log.log(log.INFO, 'RS-485 doesn\'t work')
            error_code = error_code | (1<<1)
            MODULES_STATUSES = MODULES_STATUSES | (1<<7)
        display_general_info()
        last_time_sec = time.time()
    
    if not IS_WAIT_MODBUS_RESPONSE:
        if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
            last_time_DO_1 = time.ticks_ms()
            send_modbus_req(MICOM_REQUEST_LIST[current_micom_address_index][current_MICOM_REGULAR_REGISTER_index])
        elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
            last_time_DO_0 = time.ticks_ms()
            
            
            send_modbus_req(DI_32_REQUEST_LIST[current_DI_32_address_index])
        
        last_time_modbus_req = time.ticks_ms()

    if abs(time.time() - last_time_regular_packet) >= REGULAR_PACKET_PERIOD_SECONDS:
        PACKET_FORM_STATE = REGULAR_PACKET_STATE
        last_time_regular_packet = time.time()
        
    if SERVER_SEND_STATE in [SERVER_SEND_REGULAR_STATE, SERVER_SEND_EMERGENCY_STATE] and modem_var.get_status() != -1:
        modem_var.connect_to_server()
    
    data = modem_var.process_tcpip(IS_FILE_DONWLOAD)
    
    if data and 'IP INITIAL' in data:
        SERVER_SEND_STATE = SERVER_SEND_NOT_STATE
        PACKET_FORM_STATE = EMERGENCY_PACKET_STATE
        last_time_regular_packet = time.time()
        IS_FILE_DONWLOAD = False
    elif IS_FILE_DONWLOAD:
        splited_name = new_file_name.split(".")
        File(splited_name[0] + "1." + splited_name[1]).writeln(data)
    elif data and re.search('.*<.*>.*', data):
        error_code = error_code & ~(1<<0)
        cmd_from_server = data[data.index('<')+1:data.rindex('>')]
        if "CHANGEFILE" in cmd_from_server:
            IS_FILE_DONWLOAD = True
            new_file_name = cmd_from_server[cmd_from_server.index(":") + 1:]
            splited_name = new_file_name.split(".")
            File(splited_name[0] + "1." + splited_name[1]).write("", 'w')
        elif "FILEEND" in cmd_from_server:
            IS_FILE_SUCCESS = True
            IS_FILE_DONWLOAD = False
        elif "RESTART" in cmd_from_server:
            log.log(log.INFO, f"From server reciveid cmd : restart")
            attempt_count_file.writeln("From server reciveid cmd : restart")
            machine.reset()
        elif "SETTIME" in cmd_from_server:
            str_time = cmd_from_server[cmd_from_server.index(":") + 1:]
            log.log(log.INFO, f"From server reciveid time: {str_time}")
            set_time(str_time)
    elif data and IS_FILE_DONWLOAD and "CLOSE" in data:
        modem_var.current_at_cmd_index = 3
        modem_var.ALLOW_NEXT_CMD = True
        modem_var.CHECK_IP = False
        modem_var.connect_to_server()
    elif data and 'CONNECT FAIL' in data:
        log.log(log.INFO, 'Can\'t connect to server')
    elif data and to_count < 3 and 'TIMEOUT' in data:
        log.log(log.INFO, 'Can\'t connect to server')
        to_count += 1
        modem_var.connect_to_server()
    elif to_count >= 3:
        log.log(log.INFO, 'Fail to connect to server 3 times')
        to_count = 0
        error_code = error_code | (1<<0)
        modem_var.current_at_cmd_index = -1
        display_general_info()
        packet = b''
        if SERVER_SEND_STATE == SERVER_SEND_REGULAR_STATE:
            for i in form_packet(REGULAR_PACKET_TYPE):
                packet += i
        elif SERVER_SEND_STATE == SERVER_SEND_EMERGENCY_STATE:
            for i in form_packet(EMERGENCY_PACKET_TYPE):
                packet += i
        File('unsended_packets.txt').writeln(f'{packet}')
        last_time_regular_packet = time.time()
    elif data and  '>' in str(data):
        if SERVER_SEND_STATE == SERVER_SEND_REGULAR_STATE:
            send_general_regular_packet()
        elif SERVER_SEND_STATE == SERVER_SEND_EMERGENCY_STATE:
            send_emergency_packet()
        modem_var.send_data()

    if uart.any():
        start_time = time.ticks_ms()
        while uart.any() and time.ticks_diff(time.ticks_ms(), time.ticks_ms()) < 5:
            response += uart.readline()
        if not (check_crc(response) and response[1] < 129 and (response[0] in DI_32_ADDRESSES or response[0] in MICOM_RELAY_ADDRESSES) and (len(response) == 9 or len(response) == 7)):
            response = b''
            continue
        if not (response[0] in cell_regular_values) and (response[0] in MICOM_RELAY_ADDRESSES):
            cell_regular_values[response[0]] = {}
        if not (response[0] in cell_emergency_values) and (response[0] in DI_32_ADDRESSES):
            cell_emergency_values[response[0]] =  b'\xFF\xFF\xFF\xFF' 
        try:
            if PACKET_FORM_STATE == REGULAR_PACKET_STATE and (response[0] in MICOM_RELAY_ADDRESSES):
                cell_regular_values[response[0]][current_MICOM_REGULAR_REGISTER_index] = response[3:5]
            elif (response[0] in DI_32_ADDRESSES) and not (cell_emergency_values[response[0]] == response[3 : 3 + response[2]]):
                cell_emergency_values[response[0]] = response[3 : 3 + response[2]]
                response_32_bit_value = int.from_bytes(cell_emergency_values[response[0]], "big")
                bit_index = 0
                for i in range(MAX_CELL_COUNT):
                    if not ((CELL_TYPE & 1 << i) >> i):
                        cell_emergency_mapped_view[i] = (response_32_bit_value & (15 << bit_index * DRY_CONTACT_PER_CELL_COUNT)) >> bit_index * DRY_CONTACT_PER_CELL_COUNT
                        bit_index += 1
                log.log(log.INFO, f'Parsed view of cells : {cell_emergency_mapped_view}')
                SERVER_SEND_STATE = SERVER_SEND_EMERGENCY_STATE
        except Exception as err:
            log.log(log.ERROR, str(err) + " " + str(response))
    
        if response is not None:
            if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
                cell_regular_response_fail_count[current_micom_address_index] = 0
                if current_micom_address_index + 1 == MICOM_RELAY_COUNT:
                    SERVER_SEND_STATE = SERVER_SEND_REGULAR_STATE
                if current_MICOM_REGULAR_REGISTER_index + 1 == len(MICOM_REGULAR_REGISTER):
                    current_micom_address_index = (
                        current_micom_address_index + 1
                    ) % MICOM_RELAY_COUNT
                current_MICOM_REGULAR_REGISTER_index = (current_MICOM_REGULAR_REGISTER_index + 1) % len(MICOM_REGULAR_REGISTER)
            elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
                cell_emergency_response_fail_count[current_DI_32_address_index] = 0
                current_DI_32_address_index = (
                    current_DI_32_address_index + 1
                ) % DI_32_COUNT
            response = b''
            IS_WAIT_MODBUS_RESPONSE = False
        else:
            log.log(4, "No response received.")
            
# ================================= END ================================
