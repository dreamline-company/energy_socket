import utime
import time
import binascii
import ucollections
import random
import machine
import framebuf, sys
import uos
import rp2
import re
import struct
import onewire, ds18x20

import library.ads1x15 as ads1x15
import library.w25qxx as w25qxx

from config import *
from machine import Timer
from machine import ADC
from gc import collect
# from machine import WDT
from library.flash import Flash
from library.oled import Oled
from library.modem import Modem
from library.logger import Logger
from library.file import File
from library.sc16is7xx import SC16IS7XX
from library.rtc_pcf import RTC_PCF
from library.crc import *
from library.constants import *

from machine import Pin, UART, SPI, I2C
from time import localtime, mktime, ticks_ms
# ver 1.0.3
# ------------------------------- FUNCTION ---------------------------------

def init_modules():
    MODULES_STATUSES = 255
    
    i2c0 = I2C(0, scl=Pin(13), sda=Pin(12), freq=100000)
    devices = i2c0.scan()
    log.log(log.INFO, f"I2C0 devices found: {len(devices)}")
    for device in devices:
        log.log(log.INFO, f"Decimal address: {device} | Hex address: {hex(device)}")

    # I2C1 Init
    # RTC, ADS1113, SSD1306, PCA,
    i2c1 = I2C(1, scl=Pin(11), sda=Pin(10), freq=100000)
    devices = i2c1.scan()
    log.log(log.INFO, f"I2C1 devices found: {len(devices)}")
    for device in devices:
        log.log(log.INFO, f" Decimal address: {device} | Hex address: {hex(device)}")
    log.log(log.INFO, f"I2C1 Address: {hex(i2c1.scan()[0]).upper()}")  # Display device address
    log.log(log.INFO, f"I2C1 Configuration: {str(i2c1)}")
    
    # I2C0 Init
    # RS-482-2 (SC16IS74),
    
    # SPI
    spi = SPI(0, 10_000_000, sck=Pin(18), mosi=Pin(19), miso=Pin(16))
    
    # GD25Q64 Flash 64 Kb
    cs_GD64 = Pin(26, Pin.OUT)
    cs_GD64.value(1)
    flash_gd = None
    try:
        flash_gd = Flash(spi, cs_GD64)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<0)
        log.log(log.INFO, f"W25qxx is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<0)
        log.log(log.ERROR, f"W25qxx is {e}")
        
    # DS18B20 Температура с One Wire ++
    fl_DS18B20 = False
    ds_pin = machine.Pin(15)
    ds_sensor, roms = None, None
    try:
        ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin))
        roms = ds_sensor.scan()
        ds_sensor.convert_temp()
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<1)
        log.log(log.INFO, f"Found DS18B20: {roms}")
    except Exception as e:
        fl_DS18B20 = False
        MODULES_STATUSES = MODULES_STATUSES | (1<<1)
        log.log(log.ERROR, f"DS18B20: NOT {e}")

    # OLED
    WIDTH = 128
    HEIGHT = 32
    oled = None
    try:
        oled = Oled(WIDTH, HEIGHT, i2c1)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<2)
        oled.displayText("Init Modules...", (10,10))
        log.log(log.INFO, f"OLED is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<2)
        log.log(log.ERROR, f"OLED: NOT {e}")
    
    # RTC_PCF
    adr_RTC = 0x51  # Адрес RTC DS
    adr_DT = 0x04  # Адрес регистра врeмени
    rtc_p = None
    try:
        rtc_p = RTC_PCF(i2c1)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<3)
        log.log(log.INFO, f"RTC_PCF is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<3)
        log.log(log.ERROR, f"RTC_PCF: NOT {e}")


    # ADS1113
    InVoltDivider = 18.2
    InDiod = 0.4
    addr = 0x48
    gain = 1
    ads = None
    try:
        ads = ads1x15.ADS1115(i2c1, addr, gain)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<4)
        log.log(log.INFO, f"ADS1115 is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<4)
        log.log(log.ERROR, f"ADS1115: NOT {e}")
    addr_PCA = 0x41
    i2c1.writeto(addr_PCA, b"\x03\x00")  # pin -> out

    # Port RS-485-2, через I2C. sc16is740 speed: 19200
    rs_2 = None
    try:
        i2c1.writeto(addr_PCA, b"\x01\xFF")
        rs_2 = SC16IS7XX(i2c0, debug=False)
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<5)
        log.log(log.INFO, f"SC16IS7XX is on")
    except Exception as e:
        MODULES_STATUSES = MODULES_STATUSES | (1<<5)
        log.log(log.ERROR, f"SC16IS7XX: NOT {e}")
    
    modem_var = Modem(3, (1,4,5), SERVER_IP, PORT, EMERGENCY_PHONE)
    
    oled.Oled(["Turning on", "modem ...", ""])
     
    if modem_var.on() == 1:
        log.log(log.INFO, f"Modem is on")
        oled.displayText("Modem is on", (0,0))
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<6)
    else:
        MODULES_STATUSES = MODULES_STATUSES | (1<<6)
        log.log(log.ERROR, f"cmd Mod On: Bad!")
        
    return i2c1, flash_gd, ds_sensor, roms, oled, rtc_p, ads, rs_2, modem_var, MODULES_STATUSES

def display_general_info():
    display_list = []
    
    # Вывод времени
    datetime = rtc_p.ReadTime(1)
    display_list.append(datetime)
    
    try:
        # DS18B20
        ds_sensor.convert_temp()
        temperature = do_18B20()
        dict_val['t1'] = temperature
        dict_val['t2'] = do_t_CPU(t_CPU)
        display_list.append("t_DS:{0:0.1f}".format(temperature))
    except Exception as e:
        log.log(log.ERROR, e)
        # Tемпературa CPU
        temperature = do_t_CPU(t_CPU)
        display_list.append("tCPU:{0:0.1f} ".format(temperature))
        
    # Voltage
    InVoltDivider = 18.2
    Kv = 2.048 * InVoltDivider / 32767  # делитель V
    V = read_ADS(1, 10) * Kv
    display_list[-1] = display_list[-1] + "Vs:{0:0.1f}".format(V)
    dict_val['v1'] = V
    display_list.append(f"{MODULES_STATUSES:08b}  {error_code:02X}")
    dict_val['ms'] = MODULES_STATUSES
    if not (MODULES_STATUSES & 2 << 1) >> 2:
        oled.Oled(display_list)
    else:
        print("OLED: Bad")
        
def send_modbus_req(s):
    global ms_RS, IS_WAIT_MODBUS_RESPONSE
    Pin_RS0.on()
    ms_RS = time.ticks_add(time.ticks_ms(), len(s) + 2)
    uart.write(s)
    IS_WAIT_MODBUS_RESPONSE = True
    time.sleep_ms(10)

# Получение температуры CPU
def do_t_CPU(adc_t):
    v_tcpu = adc_t.read_u16() * 3.3 / (65535)
    t1 = 27 - (v_tcpu - 0.709) / 0.001721
    return t1

# Получение Vsys
def do_Vsys():
    V = Pin_sys.read_u16() * 3.3 / (65535)
    V *= 3
    return V

# Получение t c DS18B20 (с 1 датчика)
def do_18B20():
    try:
        for rom in roms:
            t1 = ds_sensor.read_temp(rom)
        return t1
    except Exception as e:
        raise e

# Чтение канала АЦП. Канал - 1,2,3, dlit преобразования - ms
def read_ADS(Kanal, dlit):
    b = bytearray()
    b.append(0x01)
    b.append(0xFC + Kanal)
    i2c1.writeto(addr_PCA, b)
    time.sleep_ms(dlit)
    nV = ads.read(0)
    return nV

def send_general_regular_packet():
    packet = [PACKET_START_CHARACTER, OBJECT_ID, REGULAR_PACKET_TYPE, time.time().to_bytes(4, "little"), DATA_START_CHARACTER]
    for cell_number in sorted(cell_regular_values.keys()):
        packet.append(cell_number.to_bytes(1, "little"))
        for reg_num in sorted(cell_regular_values[cell_number].keys()):
            packet.extend((reg_num, REGISTER_NUM_VALUE_DELIMITER, cell_regular_values[cell_number][reg_num], REGISTER_DELIMITER))
        packet.append(DATA_DELIMITER)
    packet.extend((DATA_END_CHARACTER, DATA_START_CHARACTER))
    for name in ["v1", "t1", "t2", "ms", "re"]:
        packet.extend((name.encode(), bytearray(struct.pack("f", dict_val[name])) , DATA_DELIMITER))
    packet.extend((DATA_END_CHARACTER, PACKET_END_CHARACTER))
    log.log(log.INFO, f'Send regular packet : {packet}')
    for i in packet:
        modem_var.send_number(i) 

def send_emergency_packet(emergency_packet_data):
    to_count = 0
    while True:
        modem_var.connect_to_server()
        data = modem_var.process_tcpip()
        if data and '>' in data and not '<' in data:
            packet = [PACKET_START_CHARACTER, OBJECT_ID, EMERGENCY_PACKET_TYPE, time.time().to_bytes(4, "little"), DATA_START_CHARACTER]
            for cell_number in sorted(cell_emergency_mapped_view.keys()):
                packet.extend((cell_number.to_bytes(2, "little"), sum(cell_emergency_mapped_view[cell_number]).to_bytes(1,"little"), DATA_DELIMITER))
            packet.extend((DATA_END_CHARACTER, PACKET_END_CHARACTER))
            
            log.log(log.INFO, f'Send emergency packet : {packet}')
            for i in packet:
                modem_var.send_number(i)
            modem_var.send_data()
        elif data and 'IP INITIAL' in data:
            return 0
        elif data and to_count < 3 and 'TIMEOUT' in data:
            to_count += 1
        elif to_count >= 3:
            return -1
def send_sms():
    while True:
        modem_var.send_sms_mode_on()
        data = modem_var.process()
        if data and '>' in data:
            modem_var.send_number('MESSAGE'.encode())
            modem_var.send_number((26).to_bytes(1, "little"))
            break
            
        
    log.log(log.INFO, 'Some modules are fail to start. Send SMS message to emergency contact')

# ------------------------------- END FUNCTION ------------------------------------

# ---------------------------------START-------------------------------------------

log = Logger(f'object_{OBJECT_ID}_main.log')

ms_RS = 0  # Задержка для передачи пакета RS-485

fl_ADS = False  # ADS в процессе

PACKET_FORM_STATE = EMERGENCY_PACKET_STATE # идет ли формиравиние регулярного пакета
# EMERGENCY_PACKET_STATE - формиравиние регулярного пакета не идет
# REGULAR_PACKET_STATE - идет опрос регистров по ModBus
# SERVER_SEND_STATE - идет отправка на сервер регулярного пакета

#
IS_WAIT_MODBUS_RESPONSE = False
IS_FILE_DONWLOAD = False
IS_FILE_SUCCESS = False
# Инициализация
#
response = b''
# время передачи модбас запроса
last_time_modbus_req = time.ticks_ms()
# время передачи регулярного пакета
last_time_regular_packet = time.time()
# время для секундного цикла
last_time_sec = time.time()
# мигание
last_time_DO_0 = time.ticks_ms()
last_time_DO_1 = time.ticks_ms()

# 
dict_val = {}

# Modbus var
DI_32_REQUEST_TEMPLATE = bytearray(
    [0x01, 0x03, 0x00, 0x63, 0x00, 0x02]
)

MICOM_REQUEST_TEMPLATE = bytearray(
    [0x01, 0x03, 0x00, 0x00, 0x00, 0x01]
)

# TODO error code definition
error_codes = [0x01, 0x02, 0x03]
error_code = 0x00

# Значения регистров и входов ModBus устройств
cell_regular_values = {}
cell_emergency_values = {}


cell_regular_response_fail_count = [0 for i in range(MICOM_RELAY_COUNT)]
cell_emergency_response_fail_count = [0 for i in range(DI_32_COUNT)]
cell_emergency_mapped_view = {}

current_DI_32_address_index = 0
current_micom_address_index = 0
current_MICOM_REGULAR_REGISTER_index = 0

#
last_rs_state = 0
to_count = 0
# Pins
DO_0 = Pin(7, Pin.OUT)  # Pin Output
DO_1 = Pin(8, Pin.OUT)
DO_2 = Pin(9, Pin.OUT)
Pin(29, machine.Pin.IN)  # Напряжение с CPU
Pin_sys = ADC(3)  #
Pin_int_RS2 = Pin(28, Pin.IN, Pin.PULL_UP)  # Pin I2C --> Rs-485_2
Pin_RTC_INT = Pin(27, Pin.IN, Pin.PULL_UP)  # RTC DS3231

# LED
led = machine.Pin(25, machine.Pin.OUT)
fl_led = False
led.value(0)

# Температура CPU
t_CPU = ADC(4)

log.log(log.INFO, uos.uname())  # Общая инфо об плате

# UART
Pin_RS0 = Pin(2, Pin.OUT)  # RS-485 RE/DE
Pin_RS0.value(0)

# Модули 
i2c1, flash_gd, ds_sensor, roms, oled, rtc_p, ads, rs_2, modem_var, MODULES_STATUSES = init_modules()

# Выбираем RS порт
uart = None
if RS_PORT == 1:
    MODULES_STATUSES = MODULES_STATUSES & ~(1<<7)
    uart = UART(0, tx=machine.Pin(0), rx=machine.Pin(1))
    uart.init(baudrate=19200, bits=8, parity=None, stop=1, timeout=30)
    
# Коммутатор каналов
addr_PCA = 0x41

display_general_info()

# Функции прерываний
# interrupt от таймера - мигаем Led
timer0 = Timer()
timer0.init(
    period=1000, mode=Timer.PERIODIC, callback=lambda t: led.value(not led.value())
)
modem_var.init() 
# Базовые настройки модема
# while modem_var.init() != 2:
#     data = modem_var.process()
#     if data and data.startswith('+CCLK'):
#         sp0 = data[23:25]
#         sp0 = sp0 + data[20:22]
#         sp0 = sp0 + data[17:19]
#         sp0 = sp0 + data[14:16]
#         sp0 = sp0 + '01' #День недели
#         sp0 = sp0 + data[11:13]
#         sp0 = sp0 + data[8:10] #Год/
#         bp0 = binascii.unhexlify(sp0)
#         rtc_p.SetTime(NowTime=bp0)
#     elif data and data.startswith('TIMEOUT'):
#         # TODO
#         # send to server
#         pass

log.log(log.INFO, "Modem and time are configured")

# Счетчик перезагрузок
attempt_count_file = File('attempt.txt')
attempt_file_content = attempt_count_file.read()
attempts_count = len(attempt_file_content.split())
dict_val['re'] = attempts_count
print(dict_val['re'])
# Проверяем состояние модулей
if MODULES_STATUSES == 0:
    attempts_count = 0
elif attempts_count < 3:
    attempts_count += 1
    attempt_count_file.write(str(attempts_count), 'w')
    log.log(log.INFO, 'Some modules are fail to start. Initiate restart process')
    machine.reset()
elif not (MODULES_STATUSES & 2 << 5) >> 6 and send_general_regular_packet():
    log.log(log.INFO, 'Some modules are fail to start. Send message to server')
else:
    log.log(log.INFO, "Some modules are fail to start. 3 times attempted to restart system. Doesn't help.")
    send_sms()

while True:
    # RS-485 ключение режима передачи
    if Pin_RS0.value():
        if time.ticks_diff(time.ticks_ms(), ms_RS) <= 0:
            Pin_RS0.off()
    
    # Проверяем состояние RS-485 порта
    if 0 in cell_regular_response_fail_count or 0 in cell_emergency_response_fail_count:
        if last_rs_state == 1:
            log.log(log.INFO, 'RS-485 works')
            error_code = 0x00
            display_general_info()
        MODULES_STATUSES = MODULES_STATUSES & ~(1<<7)
        last_rs_state = (MODULES_STATUSES & 2 << 6) >> 7
    else:
        if last_rs_state == 0:
            PACKET_FORM_STATE = 2
            log.log(log.INFO, 'RS-485 doesn\'t work')
            error_code = 0x02
            display_general_info()
        MODULES_STATUSES = MODULES_STATUSES | (1<<7)
        last_rs_state = (MODULES_STATUSES & 2 << 6) >> 7
    
    # Timeout для ответа по Modbus протоколу
    if IS_WAIT_MODBUS_RESPONSE and time.ticks_diff(time.ticks_ms(), last_time_modbus_req) > 100:
        if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
            cell_regular_response_fail_count[current_micom_address_index] = 1
            if current_micom_address_index + 1 == MICOM_RELAY_COUNT:
                PACKET_FORM_STATE = SERVER_SEND_STATE
            if current_MICOM_REGULAR_REGISTER_index + 1 == len(MICOM_REGULAR_REGISTER):
                current_micom_address_index = (
                    current_micom_address_index + 1
                ) % MICOM_RELAY_COUNT
            current_MICOM_REGULAR_REGISTER_index = (current_MICOM_REGULAR_REGISTER_index + 1) % len(MICOM_REGULAR_REGISTER)
        elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
            cell_emergency_response_fail_count[current_DI_32_address_index] = 1
            current_DI_32_address_index = (
                current_DI_32_address_index + 1
            ) % DI_32_COUNT
        response = b''
        IS_WAIT_MODBUS_RESPONSE = False
        last_time_modbus_req = time.ticks_ms()
    
    # Отвечает за моргание при опросе регулярных регистров
    if PACKET_FORM_STATE in [REGULAR_PACKET_STATE,SERVER_SEND_STATE] and time.ticks_diff(time.ticks_ms(), last_time_DO_1) > 100:
        DO_1.toggle()
        DO_0.off()
        last_time_DO_1 = time.ticks_ms()  
    
    # Отвечает за моргание при опросе аварийных сигналов
    if PACKET_FORM_STATE == EMERGENCY_PACKET_STATE and time.ticks_diff(time.ticks_ms(), last_time_DO_0) > 100:
        DO_0.toggle()
        DO_1.off()
        last_time_DO_0 = time.ticks_ms()  
    
    # Рабочий цикл 1 сек
    if abs(time.time() - last_time_sec) >= 1:
        display_general_info()
        last_time_sec = time.time()
    
    # Свободная ли линия ModBus
    if not IS_WAIT_MODBUS_RESPONSE:
        # Отправка запроса на Micom
        if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
            last_time_DO_1 = time.ticks_ms()
            message = MICOM_REQUEST_TEMPLATE[:]
            message[0] = MICOM_RELAY_ADDRESSES[current_micom_address_index]
            message[2] = MICOM_REGULAR_REGISTER[current_MICOM_REGULAR_REGISTER_index][0]
            message[3] = MICOM_REGULAR_REGISTER[current_MICOM_REGULAR_REGISTER_index][1]
            
            crc = crc16(message)
            message += crc
            
            send_modbus_req(message)
        # Отправка запроса на DI32
        elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
            last_time_DO_0 = time.ticks_ms()
            DI_32_REQUEST_TEMPLATE[0] = DI_32_ADDRESSES[current_DI_32_address_index]
            message = DI_32_REQUEST_TEMPLATE[:]
            crc = crc16(message)
            message += crc
            
            send_modbus_req(message)
        
        last_time_modbus_req = time.ticks_ms()

    # Переход в режим отпроса регулярных регистров 
    if abs(time.time() - last_time_regular_packet) >= REGULAR_PACKET_PERIOD_SECONDS:
        PACKET_FORM_STATE = REGULAR_PACKET_STATE
        last_time_regular_packet = time.time()
        
    # Опрос регулярных регистров закончен можно отпралять на сервер
    if PACKET_FORM_STATE == SERVER_SEND_STATE:
        modem_var.connect_to_server()
        
    # * * * * * * * * * * * Прием с UART портов * * * * * * * * * * *
    
    # Получние ответа от модема
    data = modem_var.process_tcpip()
    
    # TODO
    # different dialoge window when comm
    
    # Успешное закрытие соединения с сервером
    if data and 'IP INITIAL' in data:
        # Переход в опрос аварийных сигналов
        PACKET_FORM_STATE = EMERGENCY_PACKET_STATE
        last_time_regular_packet = time.time()
    elif data and re.search('.*<.*>.*', data):
        error_code = 0x00
        cmd_from_server = data[data.index('<')+1:data.rindex('>')]
        if "CHANGEFILE" in cmd_from_server:
            IS_FILE_DONWLOAD = True
            new_file_name = cmd_from_server[cmd_from_server.index(":") + 1:]
            modem_var.send_at_cmd()
        elif "NEXTLINE" in cmd_from_server:
            File('attempt.txt').writeln(cmd_from_server[cmd_from_server.index(":") + 1:])
        elif "FILEEND" in cmd_from_server:
            IS_FILE_SUCCESS = True
            IS_FILE_DONWLOAD = False
            modem_var.send_at_cmd()
        elif "RESTART" in cmd_from_server:
            machine.reset()
        elif "SETTIME" in cmd_from_server:
            pass
    elif data and 'CONNECT FAIL' in data:
        log.log(log.INFO, 'Can\'t connect to server')
    elif data and to_count < 3 and 'TIMEOUT' in data:
        to_count += 1
        modem_var.connect_to_server()
    elif to_count >= 3:
        to_count = 0
        error_code = 0x01
        modem_var.current_at_cmd_index = 0
        display_general_info()
        PACKET_FORM_STATE = EMERGENCY_PACKET_STATE
        last_time_regular_packet = time.time()
    # Модем ожидает данных для отправки на сервер
    elif data and  '>' in str(data):
        if IS_FILE_DONWLOAD:
            modem_var.send_str(f"<{OBJECT_ID}CMD:NEXTLINE>".encode())
        elif IS_FILE_SUCCESS:
            IS_FILE_SUCCESS = False
            modem_var.send_str(f"<{OBJECT_ID}CMD:FILESUCCESS>")
        else:
            send_general_regular_packet()
        modem_var.send_data()

    # Проверка на наличие ответа от подключенных устройств по Modbus протоколу 
    if uart.any():
        start_time = time.ticks_ms()
        
        # Чтение всех данных если не все были прочитанны с первой попытки
        while uart.any() and time.ticks_diff(time.ticks_ms(), time.ticks_ms()) < 5:
            # Чтение ответа от подключенных устройств по Modbus протоколу
            response += uart.readline()
            
        # Проверка на валдность адрес в ответе, валидность фун. кода, правильно ли расчитан crc
        if not (check_crc(response) and response[1] < 129 and (response[0] in DI_32_ADDRESSES or response[0] in MICOM_RELAY_ADDRESSES)):
            response = b''
            continue
        
        # Есть ли запись состояния данного устройство 
        if not (response[0] in cell_regular_values) and (response[0] in MICOM_RELAY_ADDRESSES):
            cell_regular_values[response[0]] = {}
        if not (response[0] in cell_emergency_values) and (response[0] in DI_32_ADDRESSES):
            cell_emergency_values[response[0]] =  b'\xFF\xFF\xFF\xFF'
                        
        try:
            # Разбираем ответ от устройтво Micom
            if PACKET_FORM_STATE == REGULAR_PACKET_STATE and (response[0] in MICOM_RELAY_ADDRESSES):
                cell_regular_values[response[0]][MICOM_REGULAR_REGISTER[current_MICOM_REGULAR_REGISTER_index]] = response[4:6]
            # Проверяем изменились ли аварийные сигналы
            elif (response[0] in DI_32_ADDRESSES) and not (cell_emergency_values[response[0]] == response[3 : 3 + response[2]]):
                cell_emergency_values[response[0]] = response[3 : 3 + response[2]]
                for i in range(len(cell_emergency_values[response[0]])):
                    for j in range(i * 8, (i + 1) * 8):
                        cell_conn = DI_32_DRY_CONTACT_CONN_MAP[j]
                        if not (cell_conn[0] in cell_emergency_mapped_view):
                            cell_emergency_mapped_view[cell_conn[0]] = []
                        if (cell_emergency_values[response[0]][i] & 1 << (7 - j%8)) >> (7 - j%8) and not (cell_conn[1] in cell_emergency_mapped_view[cell_conn[0]]):
                                cell_emergency_mapped_view[cell_conn[0]].append(cell_conn[1])
                        elif cell_conn[1] in cell_emergency_mapped_view[cell_conn[0]]:
                            cell_emergency_mapped_view[cell_conn[0]].remove(cell_conn[1])    
                log.log(log.INFO, f'Parsed view of cells : {cell_emergency_mapped_view}')
                if send_emergency_packet(cell_emergency_values) == -1:
                    error_code = 0x01
                    display_general_info()
        except Exception as err:
            log.log(log.ERROR, str(err))
    
        # При успешном ответе переходим на следующие устройство
        if response is not None:
            if PACKET_FORM_STATE == REGULAR_PACKET_STATE:
                cell_regular_response_fail_count[current_micom_address_index] = 0
                if current_micom_address_index + 1 == MICOM_RELAY_COUNT:
                    PACKET_FORM_STATE = SERVER_SEND_STATE
                if current_MICOM_REGULAR_REGISTER_index + 1 == len(MICOM_REGULAR_REGISTER):
                    current_micom_address_index = (
                        current_micom_address_index + 1
                    ) % MICOM_RELAY_COUNT
                current_MICOM_REGULAR_REGISTER_index = (current_MICOM_REGULAR_REGISTER_index + 1) % len(MICOM_REGULAR_REGISTER)
            elif PACKET_FORM_STATE == EMERGENCY_PACKET_STATE:
                cell_emergency_response_fail_count[current_DI_32_address_index] = 0
                current_DI_32_address_index = (
                    current_DI_32_address_index + 1
                ) % DI_32_COUNT
            response = b''
            IS_WAIT_MODBUS_RESPONSE = False
        else:
            log.log(4, "No response received.")
            
# ================================= END ================================

2
